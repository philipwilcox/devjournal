# 2018.01 Android Widget Development

## 2018.01.29

I installed Android Studio per the instructions on the website. I'm
pretty familiar with IntelliJ, so not bothering documenting all that.

My initial project idea is to learn about widgets and the system APIs
for creating a widget for dealing with alarms and timers. We'll see
how possible/practical this is.

I decided to use the latest API, 27, for Android 8.1 since I'm
interested in learning the newest recommendations and don't need my
personal apps running on other devices.

I also decided to use Kotlin since I've played with it before as a
Java alternative and like its reduced verbosity.

40 minutes of downloading and configuring (mostly downloading) got me
this starting point repo: https://github.com/philipwilcox/ClockManager

Note that I created this as an empty activity, not knowing anything
about them to guide my starting point otherwise.

Trying to run it out of the box gives me a dialog showing that I
already have a "Nexus 5X API 27 x86" virtual device, which seems fine
for now. I'll connect my phone later.
* It blows up with "Missing initial data partition file" wtf...
* https://stackoverflow.com/questions/47895124/emulator-emulator-error-missing-initial-data-partition-file well that's stupid, but yeah, running a second time fixed that, but it's actually failing on trying to load openGL drivers!
* Setting it to software graphics driver fixes that, seems there's an old bug that I need to work around for getting hardware graphics working later with Intel drivers... https://bbs.archlinux.org/viewtopic.php?id=213192

I'll pick up there later, bleh.

## 2018.01.30

Left off from yesterday with an emulator that wouldn't boot at all.
* Fixed booting with software graphics by creating a new Pixel profile emulator running Android 26 API x86\_64 image. Not sure if API version change or x86\_64 vs x86 that did the trick.
* Hardware graphics mode problem still exists.
  * Looking at https://askubuntu.com/questions/867081/android-studio-buggy-after-upgrade-to-16-10
  * Trying the `export ANDROID_EMULATOR_USE_SYSTEM_LIBS=1` in `.profile` suggestion. No luck even after restarting Android studio.
  * This did the trick, sigh:
    ```bash
    ðŸ˜Š  [Tue Jan 30 12:45:20] philip@thinkphil25:~/Android 
    ðŸ’°  cd ~/Android/Sdk/emulator/lib64
    ðŸ˜Š  [Tue Jan 30 12:45:58] philip@thinkphil25:~/Android/Sdk/emulator/lib64 
    ðŸ’°  mv libstdc++ libstdc++.bad
    ```

Now that I have an environment, I'll jump into coding later. Frustrating setup to have to debug before I can even do a hello world.

## 2018.02.01

Today I picked up by starting to write my own code. First task: try to
read the next alarm time from the system. One stackoverflow post
mentioned AlarmManager,
https://developer.android.com/reference/android/app/AlarmManager.html,
though it's unclear if this will work for system level alarms or just
scheduling events for the app.

Ended up with this after some kotlin kung-fu to convert the Java
example commands. I learned the cast from the interactive debugger:
```kotlin
var alarmManager = applicationContext.getSystemService(Context.ALARM_SERVICE);
var nextAlarm = (alarmManager as AlarmManager).nextAlarmClock
```

By default in an empty simulator, nextAlarm is null. Had to do a brief
digression to learn how to use the log: `Log.e` will print an
error-level log to the Logcat tab in Android Studio (which will color
it red for noticability), but I got my emulator confused and had to
restart Android Studio to get it to find the process correctly.

Next task: change the emulator to have an alarm set, and see if it
still comes back as `null`. *This works!* It gives me a non-null
`AlarmClockInfo` object with a numeric mTriggerTime. I can get that
trigger time into a string like so:
```kotlin
DateUtils.formatDateTime(applicationContext, nextAlarm.triggerTime, DateUtils.FORMAT_SHOW_DATE or DateUtils.FORMAT_SHOW_TIME)
```

Then `1517578200000` turns into `February 2, 8:30 AM`.

Note the "or" bitwise operator in Kotlin. :|

Speaking of, this looks handy:
https://kotlinlang.org/docs/reference/idioms.html - like this
if-not-null shorthand:
```kotlin
val files = File("Test").listFiles()

println(files?.size)
```
or execute if not null oddity:
```kotlin
val value = ...

value?.let {
    ... // execute this block if not null
}
```
(Are we sure this one's so great? Here's some discussion: https://discuss.kotlinlang.org/t/let-vs-if-not-null/3542 -- interesting how it turns the thing being tested into `it`, too, which shortens things a tiny bit in trivial cases but would be cool for more complex nested checks.)


## 2018.02.02

Today I'm backing up and studying some basics first:
* https://developer.android.com/guide/components/fundamentals.html
  * App components - basic building blocks. Four types:
	* Activities - entry point for interacting with user. Single screen w/ UI. By knowing what
      activity the user is in, the system can keep the right processes running, suspend the right
      processes, and save the right state for those processes, as well as sharing stuff app to app.
	* Services - entry point for running in the background. Performs long-running operations, or
      performs work for other processes. No UI.
	  * Started services tell the system to keep them running until work is done.
	  * Bound services run because another app says that it wants to use them, e.g. as an API for
        another process.
		> Live wallpapers, notification listeners, screen savers, input methods, accessibility services, and many other core system features are all built as services that applications implement and the system binds to when they should be running.
	* Broadcast receivers - the entry point to respond to system-wide announcements. This way
      broadcasts can hit even apps that aren't currently running. May create a status bar
      notification, but doesn't display UI.
	  > So, for example, an app can schedule an alarm to post a notification to tell the user about
	  > an upcoming event... and by delivering that alarm to a BroadcastReceiver of the app, there
	  > is no need for the app to remain running until the alarm goes off. Many broadcasts originate
	  > from the systemâ€”for example, a broadcast announcing that the screen has turned off, the
	  > battery is low, or a picture was captured. Apps can also initiate broadcastsâ€”for example, to
	  > let other apps know that some data has been downloaded to the device and is available for
	  > them to use.
	  * Broadcasts are delivered as `Intent` objects.
	* Content providers - this lets *other apps* query shared app data that your app stores in
      persistent storage (local or web or wherever).
	  > For example, the Android system provides a content provider that manages the user's contact
	  > information. As such, any app with the proper permissions can query the content provider,
	  > such as ContactsContract.Data, to read and write information about a particular person.
	  * Need to think more about what this bit means, some more details on the page:
	  > It is tempting to think of a content provider as an abstraction on a database, because there
	  > is a lot of API and support built in to them for that common case. However, they have a
	  > different core purpose from a system-design perspective. To the system, a content provider
	  > is an entry point into an app for publishing named data items, identified by a URI scheme.
  * Activating components
	* Three of four are actived with an `Intent` object: Activities, services, and broadcast
      receivers.
	  * Start an activity, or change what it's doing, by passing `Intent` to `startActivity()` or
        `startActivityForResult()`, the latter meaning you want the result back from the activity.
	  * `JobScheduler` class can be used to schedule actions (sends the `Intent` to a service, seems
        like).
	  * Initiate a broadcast by passing an `Intent` to `sendBroadcast()` or similar.
	* ContentProviders activated when targeted by a request from a `ContentResolver`. This means
      calling `query()` on a `ContentResolver`.
  * Manifest file
	* App must declare all components in here, must be in root of app project dir
	* Also identifies permissions, minimum API level, hardware/software features used, and API
      libraries other than framework to link against.
	* __*I don't think I need to go deep into declaring components and capabilities for now...*__
  * App resources: images, audio, xml, blah blah blah.

All this structure stuff is good background context, but in keeping with my "add structure as proven
needed" approach, I'm not too worried about figuring out exactly what to put in what classes as
activities or services or other helpers or what, just right now. I'll figure that out as I go, to
avoid having to back out of a wrong design since I know very little right now anyway.

* https://developer.android.com/guide/components/activities/activity-lifecycle.html
  * My initial thinking is that I'll have an activity that triggers a service when it's opened to
    enable the widget and all, but I'll learn more there later.
  * Lifecycle callbacks for activities ensure that:
	* Multitasking works (user can receive a phone call or switch apps while in your app without
      breaking)
	* The app doesn't use too many resources when backgrounded
	* The user doesn't lose their progress when multitasking
	* The app handles screen rotation (welp, hadn't thought about this, design-wise, lol)
  * The core callbacks are:
    * `onCreate`
	* `onStart`
	* `onResume`
	* `onPause`
	* `onStop`
	* `onDestroy`

But again, I'll come back to the details of this later.

Going back to the question of managing the clock app's alarms:
* https://stackoverflow.com/questions/13909040/set-android-alarm-clock-programmatically This one
  isn't too encouraging. I need to make sure I'm talking to the clock, not just the system alarm
  scheduling stuff. What's puzzling me is that the get next alarm thing *does* respect alarms set
  there, not just own-app stuff.
* https://developer.android.com/reference/android/provider/AlarmClock.html Here's a provider for
  creating an Intent to start an Activity to set a new alarm or timer in an alarm clock app. What
  can I do with this...?
  
  >  Applications that wish to create a new alarm or timer should use Context.startActivity() so
  >  that the user has the option of choosing which alarm clock application to use.

  * https://developer.android.com/reference/android/provider/AlarmClock.html#ACTION_SHOW_ALARMS This
    will open a page to see alarms, but I want to show some in my own UI first, too...
	
  * https://developer.android.com/reference/android/provider/AlarmClock.html#ACTION_SHOW_TIMERS Same
    as above, but for timers.

Seems like one thing I should try is to schedule my own event with AlarmManager and then see if
  this preempts my access to seeing when the system alarm is set.
  * There's a broadcast action `ACTION_NEXT_ALARM_CLOCK_CHANGED` that indicates when that is
    changed, would want to listen to that too.
  * There's a few methods here for `set` and `cancel`, are they reflected in system alarm clock app?
  * And there seems to be no way to get the whole list of them... how do widgets show the next
    system alarm reliably, then??

If I can't manage the alarms directly, I could still implement my own timers since no need to
piggyback on system for that. But for wakeup alarm I really want to use the native UI so I have the
native snooze functionality and all. In that case the app is just TimerManager I guess.

---

Back to code and Kotlin, fun rediscovery: nullable things will come back as `Any!` by default from
Java calls, so I'll need to unbox them to have proper behavior, null safety, and
autocompletion. Basic info here: https://kotlinlang.org/docs/reference/null-safety.html

So doing something like `val alarmManager =
(applicationContext.getSystemService(Context.ALARM_SERVICE)) as AlarmManager` will give me an object
of the expected type but it's not clear to me yet if that's the prefered way. But doing a quick test confirms it behaves as I'd expect, at least: `val blah = (null as AlarmManager)` causes a fatal NPE, which is fine for now.

I also wasn't entirely clear on difference between `Any?` and `Any!`, but this seems to clear it up: https://stackoverflow.com/questions/43826699/single-exclamation-mark-in-kotlin - `Any!` is when Kotlin isn't sure if it's nullable or not for a "platform type."

__*Another side note to learn more about later: `icu` libraries in Android. Seems
internationalization-related.*__

This is an interesting discovery that wasn't clear from my reading of the docs: `nextAlarmClock`
ignores stuff set with `AlarmManager.set` even in the same process? See the following code:

```kotlin
val alarmManager = (applicationContext.getSystemService(Context.ALARM_SERVICE)) as AlarmManager
// Let's set a test alarm and see if that's what we get back instead
val calendar = Calendar.getInstance()
alarmManager.set(AlarmManager.RTC, calendar.getTimeInMillis() + 20000, null);

var nextAlarm = alarmManager.nextAlarmClock
Log.e("AlarmManager: ", "$nextAlarm")
nextAlarm?.let {
	var alarmString = DateUtils.formatDateTime(applicationContext, it.triggerTime,
			DateUtils.FORMAT_SHOW_DATE or DateUtils.FORMAT_SHOW_TIME)
	Log.e("AlarmManager", "Next alarm will trigger at $alarmString")
}
```

This ends up logging:
```
02-02 15:49:47.149 8734-8734/? E/AlarmManager: Next alarm will trigger at February 5, 8:30 AM
```

So that's curious, but it's still just one alarm, the next one, which is less useful and gives no
access to timers in the app. Time to find out if the AOSP/Pixel clock is a ContentProvider, I
guess. Seems probably hopeless based on
https://stackoverflow.com/questions/21553196/detect-default-alarm-clock-application-alarms so next
step will be to regroup and think about how to design app to store its own timers?

Though let's take a look at this: https://developer.android.com/guide/components/intents-common.html

> To show the list of alarms, use the `ACTION_SHOW_ALARMS` action.
>
> Although not many apps will invoke this intent (it's primarily used by system apps), any app that
> behaves as an alarm clock should implement this intent filter and respond by showing the list of
> current alarms.

Can I send that intent to a different app programatically?

There's also a `ACTION_SET_TIMER` action, and as a I noted above, a related one for showing them,
let's start playing around with those!
